import asyncio
import json
import logging
from datetime import datetime

import discord
from discord.ext import commands

import database
from models.modMember import get_mod_member

WELCOME_CHANNEL = "üì¢annonces"


class Roles(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

        with open("static/json/reacts_pairs.json", encoding="utf-8") as f:
            self.reacts_pairs = json.load(f)

        self.fieldnames = {
            "Prof": "DM_choice_categories",
            "√âl√®ve G1": "DM_choice_roles_G1",
            "√âl√®ve G2": "DM_choice_roles_G2",
        }

    @commands.Cog.listener()
    async def on_member_join(self, member):
        """
        When a member join a guild, insert it in database or restore all its data
        """
        if mod_member := get_mod_member(self.bot, member):
            await member.add_roles(
                mod_member.main_role,
                reason="The user was already register, re-attribute the main role",
            )
            await mod_member.add_sub_roles()
        else:
            sql = f"INSERT INTO members (member_id, name) VALUES ({member.id}, '{member.name}')"
            database.execute(sql)
            default_role = discord.utils.get(member.guild.roles, name="Non V√©rifi√©")
            await member.add_roles(default_role, reason="User was not verified")

        text = f"{member.mention} a rejoint le serveur {member.guild.name}!"
        embed = discord.Embed(
            title="Arriv√©e d'un membre!", colour=0xFF22FF, description=text
        )
        embed.set_thumbnail(url=member.avatar_url)
        embed.set_author(name=member.name, url=member.avatar_url)
        embed.set_footer(
            text=f"Generated by {self.bot.user.name} | {datetime.now():%D - %H:%M}"
        )

        publish_channel = discord.utils.get(member.guild.channels, name=WELCOME_CHANNEL)
        await publish_channel.send(embed=embed)

    async def send_choice(self, ctx, name):
        """Generate a welcome message to choice roles to manage permissions"""

        with open(f"static/txt/{name}.txt", encoding="utf-8") as content:
            embed = discord.Embed(
                title="Bienvenue!", colour=0xFF22FF, description=content.read()
            )
            embed.set_thumbnail(url=ctx.guild.icon_url)
            embed.set_footer(
                text=f"Generated by {self.bot.user.name} | {datetime.now():%D - %H:%M}"
            )
            message = await ctx.send(embed=embed)

        for reaction in self.reacts_pairs[name]:
            await message.add_reaction(reaction)

        return message

    @commands.command(name="guild_choice", hidden=True)
    @commands.is_owner()
    async def send_guild_choice(self, ctx):
        """Generate a welcome message to choice roles to manage permissions"""
        await ctx.message.delete()
        message = await self.send_choice(ctx, "guild_choice")
        with open("static/json/messages_id.json") as f:
            messages_id = json.load(f)
            messages_id["guild_choice"] = message.id
        with open("static/json/messages_id.json", "w") as f:
            json.dump(messages_id, f)

    @commands.Cog.listener("on_raw_reaction_add")
    @commands.guild_only()
    async def reaction_guild_choice(self, payload):

        with open("static/json/messages_id.json") as f:
            message_id = json.load(f)["guild_choice"]
        if message_id != payload.message_id or payload.user_id == self.bot.user.id:
            return

        mod_member = get_mod_member(self.bot, payload.member)
        try:
            role_name = self.reacts_pairs["guild_choice"][payload.emoji.name]
            await mod_member.update_main_role(role_name)
        except KeyError:
            await mod_member.dm_channel.send(
                f"{mod_member.mention} Cette r√©action est invalide"
            )
        except AttributeError:
            logging.error(
                f"The user {mod_member.name} was not registered in members table of database"
            )
        else:
            fieldname = self.fieldnames.get(mod_member.main_role.name)
            message = await self.send_choice(mod_member, fieldname)
            mod_member.dm_choice_msg_id = message.id
            # delete the roles in sub_roles list if the user already choice in
            # the past
            with open("static/json/members_sub_roles.json") as f1:
                sub_roles = json.load(f1)
                sub_roles[str(mod_member.id)] = []
            with open("static/json/members_sub_roles.json", "w") as f2:
                json.dump(sub_roles, f2)

    @commands.Cog.listener("on_raw_reaction_add")
    @commands.Cog.listener("on_raw_reaction_remove")
    @commands.dm_only()
    async def reaction_sub_role_add(self, payload):
        """React when a member choice his roles  in DM channel"""
        mod_member = get_mod_member(self.bot, payload.user_id)

        if mod_member and payload.message_id == mod_member.dm_choice_msg_id:
            if mod_member.validate_state == 2:
                await mod_member.send(
                    "Vous ne pouvez plus red√©finir vos choix, veuillez contacter un mod√©rateur."
                )
                return
        else:
            return

        fieldname = self.fieldnames.get(mod_member.main_role.name)
        try:
            emoji_value = self.reacts_pairs[fieldname][payload.emoji.name]
        except KeyError:
            await mod_member.send("Cette r√©action est invalide")
            return

        with open("static/json/members_sub_roles.json") as f:
            sub_roles = json.load(f)
            member_list = sub_roles.get(str(mod_member.id), [])
            if payload.event_type == "REACTION_ADD":
                sub_roles[str(mod_member.id)] = member_list + [emoji_value]
            else:
                sub_roles[str(mod_member.id)].remove(emoji_value)

        with open("static/json/members_sub_roles.json", "w") as f:
            json.dump(sub_roles, f)

        if mod_member.validate_state == 0:
            await self.send_sub_roles_validate(mod_member)

    async def send_sub_roles_validate(self, mod_member):
        """Update sub roles list in json file"""
        embed = discord.Embed(
            title="Confirmation",
            colour=0xFF22FF,
            description="Voulez-vous valider votre s√©lection?",
        )
        embed.set_footer(text="This message will be disappear in 60 seconds.")
        message = await mod_member.send(embed=embed)
        await message.add_reaction("‚úÖ")
        await message.add_reaction("‚ùå")
        mod_member.validate_state = 1

        def check(reaction, user):
            if reaction.message.id == message.id and mod_member.id == user.id:
                return str(reaction.emoji) == "‚úÖ" or str(reaction.emoji) == "‚ùå"

        try:
            reaction, user = await self.bot.wait_for(
                "reaction_add", timeout=60.0, check=check
            )
        except asyncio.TimeoutError:
            await mod_member.send("Le d√©lai de confirmaton a expir√©")
            mod_member.validate_state = 0
        else:
            if str(reaction.emoji) == "‚úÖ":
                await mod_member.add_sub_roles()
                embed = discord.Embed(
                    title=f"Vous √™tes 'fin pr√™t, cher {mod_member.main_role}!",
                    colour=0xFF22FF,
                    description="Vos choix ont √©t√© pris en compte, vous devez avoir √† \
                    pr√©sent acc√®s aux salons!",
                )
                await mod_member.send(embed=embed)
                mod_member.validate_state = 2
            else:
                mod_member.validate_state = 0
                await mod_member.send("Vos choix ont √©t√© d√©clin√©s.")
        finally:
            await message.delete()


def setup(bot):
    bot.add_cog(Roles(bot))

from __future__ import annotations

import asyncio
import json
import logging
from datetime import datetime

import discord
from discord.ext.commands import Cog, command, guild_only, is_owner
from sqlalchemy import select, update

from pyboss import STATIC_DIR
from pyboss.models import GuildModel, MemberModel
from pyboss.utils import database
from pyboss.wrappers.guild import GuildWrapper
from pyboss.wrappers.member import MemberWrapper


class Roles(Cog):
    """
    Offers an interface to manage roles and send messages
    to choice his roles inside the guild
    """

    FIELDNAMES = {
        "Prof": "DM_choice_categories",
        "Élève G1": "DM_choice_roles_G1",
        "Élève G2": "DM_choice_roles_G2",
    }

    def __init__(self, bot):
        self.bot = bot

        with open(STATIC_DIR / "json/reacts_pairs.json", encoding="utf-8") as f:
            self.reacts_pairs = json.load(f)

    async def send_choice(self, ctx, name: str) -> discord.Message:
        """
        Generate a welcome message to choice roles to manage permissions
        """
        with open(STATIC_DIR / f"text/{name}.md", encoding="utf-8") as content:
            embed = discord.Embed(
                title="Bienvenue!", colour=0xFF22FF, description=content.read()
            )
            embed.set_thumbnail(url=ctx.guild.icon_url)
            embed.set_footer(
                text=f"Generated by {self.bot.user.name} | {datetime.now():%D - %H:%M}"
            )
            message = await ctx.send(embed=embed)

        for reaction in self.reacts_pairs[name]:
            await message.add_reaction(reaction)

        return message

    @command(name="guild_choice", hidden=True)
    @is_owner()
    async def send_guild_choice(self, ctx):
        """
        Generate a welcome message to choice a role in order to manage permissions
        """
        await ctx.message.delete()
        message = await self.send_choice(ctx, "guild_choice")

        database.execute(
            update(GuildModel)
            .where(GuildModel.id == ctx.guild.id)
            .values(message_roles_id=message.id)
        )

    @Cog.listener("on_raw_reaction_add")
    @guild_only()
    async def reaction_guild_choice(self, payload):
        """
        Update top role or send a DM message to the user to choice his sub roles
        """
        guild_model = database.execute(
            select(GuildModel).where(GuildModel.id == payload.guild_id)
        ).scalar_one_or_none()
        if guild_model and guild_model.message_roles_id != payload.message_id:
            return  # Exit if it's not for the message to choice roles

        member = MemberWrapper(payload.member)
        try:
            role_name = self.reacts_pairs["guild_choice"][payload.emoji.name]
            await member.remove_roles(member.top_role)
            await member.add_roles(member.guild.get_role_by_name(role_name))
        except KeyError:
            await member.dm_channel.send(
                f"{member.mention} Cette réaction est invalide"
            )
        except AttributeError:
            logging.error(f"The user {member.name} was not registered in members table")
        else:
            fieldname = self.FIELDNAMES.get(member.top_role.name)
            message = await self.send_choice(member, fieldname)
            member.choice_msg_id = message.id

    @Cog.listener("on_raw_reaction_add")
    @Cog.listener("on_raw_reaction_remove")
    async def reaction_sub_role_add(self, payload):
        """
        React when a member choice his roles in DM channel
        """
        if hasattr(payload, "guild_id"):
            return

        def get_guild_by_choice_msg(msg_id: int) -> discord.Guild:
            member_model = database.execute(
                select(MemberModel).where(MemberModel.choice_msg_id == msg_id)
            ).scalar_one()
            return self.bot.get_guild(member_model.guild_id)

        guild = GuildWrapper(get_guild_by_choice_msg(payload.message_id))
        member = MemberWrapper(guild.get_member_by_id(payload.user_id))

        if not member or payload.message_id != member.dm_choice_msg_id:
            return
        elif member.sub_roles:
            await member.send(
                "Vous ne pouvez plus redéfinir vos choix, "
                "veuillez contacter un modérateur."
            )
            return
        else:  # The member hasn't any sub role yet
            await self.send_sub_roles_validate(member)

        fieldname = self.FIELDNAMES.get(member.top_role.name)
        try:
            emoji_value = self.reacts_pairs[fieldname][payload.emoji.name]
        except KeyError:
            await member.send("Cette réaction est invalide")
            return

        role = guild.get_role_by_name(emoji_value)
        if payload.event_type == "REACTION_ADD":
            member.sub_roles += {role}
        else:
            member.sub_roles -= {role}

    async def send_sub_roles_validate(self, member: discord.Member | MemberWrapper):
        """
        Update sub roles list in json file
        """
        embed = discord.Embed(
            title="Confirmation",
            colour=0xFF22FF,
            description="Voulez-vous valider votre sélection?",
        )
        embed.set_footer(text="This message will be disappear in 60 seconds.")
        message = await member.send(embed=embed)
        await message.add_reaction("✅")
        await message.add_reaction("❌")

        def check(react, usr):
            if react.message.id == message.id and member.id == usr.id:
                return str(react.emoji) in ("✅", "❌")
            return False

        try:
            reaction, _ = await self.bot.wait_for(
                "reaction_add", timeout=60.0, check=check
            )
        except asyncio.TimeoutError:
            await member.send("Le délai de confirmaton a expiré")
        else:
            if str(reaction.emoji) == "✅":
                await member.add_roles(
                    member.sub_roles, reason="The member has selected this matter"
                )
                embed = discord.Embed(
                    title=f"Vous êtes 'fin prêt, cher {member.main_role}!",
                    colour=0xFF22FF,
                    description="Vos choix ont été pris en compte, vous devez avoir à"
                    "présent accès aux salons!",
                )
                await member.send(embed=embed)
            else:
                await member.send("Vos choix ont été déclinés.")
        finally:
            await message.delete()


def setup(bot):
    bot.add_cog(Roles(bot))
